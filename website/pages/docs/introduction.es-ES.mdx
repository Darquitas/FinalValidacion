import { Disclosures } from '../../components/home/faq';
import { Callout, Tab, Tabs } from 'nextra-theme-docs';
import Link from 'next/link';
import dynamic from 'next/dynamic';

export const Demo = dynamic(() =>
  import('../../components/demo').then((mod) => mod.Demo),
);

# Introducci√≥n

Millions.js es un compilador de optimizaci√≥n extremadamente r√°pido y liviano que hace que los [componentes](https://react.dev) sean hasta un [_**70% m√°s r√°pidos**_](https://krausest.github.io/js-framework-benchmark/current.html).

**En resumen:** Imagina componentes de [React](https://react.dev) ejecut√°ndose a la velocidad de JavaScript puro.

## ¬øPor qu√© Million.js?


Para entender por qu√© utilizar Million.js, necesitamos comprender c√≥mo React actualiza interfaces. Cuando cambian el estado o las propiedades de una aplicaci√≥n, React realiza una actualizaci√≥n en dos partes: renderizaci√≥n y reconciliaci√≥n.

Para ilustrar esto, supongamos que este es nuestro componente `App`:

```jsx
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

En este componente `App`, cuando hacemos clic en el bot√≥n, el estado `count` se actualizar√° y, consecuentemente, la etiqueta `<p>` se actualizar√° para reflejar el nuevo valor. Analicemos esto.

### Renderizaci√≥n

El primer paso es la renderizaci√≥n. La renderizaci√≥n es el proceso de generar un *snapshot* del componente actual. Puedes imaginarlo como simplemente llamar a la funci√≥n App y almacenar su resultado en una variable. As√≠ es como se ver√≠a el *snapshot* de `App`:

```jsx
const snapshot = App();

// snapshot =
<div>
  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>;
```

### Reconciliaci√≥n

Para actualizar la interfaz y reflejar el nuevo estado, React necesita comparar el *snapshot* anterior con el nuevo (llamado "diffing"). El *reconciliador* de React analizar√° cada elemento del *snapshot* anterior y lo comparar√° con el nuevo. Si el elemento es el mismo, lo omitir√°. Si el elemento es diferente, lo actualizar√°.

- La etiqueta `<div>` es la misma, as√≠ que no necesita ser actualizada. ‚úÖ
  - La etiqueta `<p>` es la misma, as√≠ que no necesita ser actualizada. ‚úÖ
    - El texto dentro de `<p>` es diferente, por lo que necesita ser actualizado. ‚ö†
  - La etiqueta `<button>` es la misma, as√≠ que no necesita ser actualizada. ‚úÖ
    - La propiedad `onClick` es la misma, as√≠ que no necesita ser actualizada. ‚úÖ
    - El texto dentro de `<button>` es la mismo, as√≠ que no necesita ser actualizado. ‚úÖ

_(total: 6 diff checks)_

```diff
<div>
-  <p>Count: 0</p>
+  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>
```

Desde aqu√≠, podemos ver que la etiqueta `<p>` necesita ser actualizada. React, por lo tanto, actualizar√° el nodo de `<p>` en el DOM para reflejar el nuevo valor.

```jsx
<p>.innerHTML = `Count: ${count}`;
```

### C√≥mo Million.js acelera esto

React es lento.


El problema con la *reconciliaci√≥n* de React es que se vuelve exponencialmente m√°s lenta a medida que aumenta la cantidad de elementos JSX. Con este simple componente `App`, solo necesita comparar algunos elementos. En una aplicaci√≥n React del mundo real, f√°cilmente puedes tener cientos de elementos, ralentizando las actualizaciones de la interfaz.

Million.js resuelve omitiendo completamente el paso de comparaci√≥n y actualizando directamente el nodo del DOM.

Aqu√≠ tienes un ejemplo conceptual de c√≥mo funciona el *reconciliador* de Million.js:

```jsx
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);

  // generado por el compilador
  if (count !== prevCount) {
    <p>.innerHTML = `Count: ${count}`;
  }

  <button>.onclick = increment;

  // ...
}
```

Observa que cuando `count` se actualiza, Million.js actualizar√° directamente el nodo DOM. Million.js transforma la *reconciliaci√≥n* de React de `O(n^3)` (tiempo c√∫bico) a `O(1)` (tiempo constante).

> ¬øQu√© tan r√°pido es? [**‚Üí Ver las pruebas de rendimiento**](https://krausest.github.io/js-framework-benchmark/current.html)

## Configuraci√≥n en segundos

La interfaz de l√≠nea de comandos (CLI) de Million.js instalar√° autom√°ticamente el paquete y configurar√° tu proyecto por ti.

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']} storageKey="selected-manager">
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  npx million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  pnpx million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  yarn add million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  bunx million@latest
  ```
  </Tab>
</Tabs>

<Callout type="info">
Million.js es compatible con React 16 y versiones posteriores. Si est√°s utilizando una versi√≥n m√°s antigua de React, deber√°s realizar una actualizaci√≥n primero.
</Callout>

¬°Eso es todo! Tu proyecto ahora est√° en funcionamiento con Million.js üéâ

## Million.js vs. React


Lo siguiente es una demostraci√≥n que utiliza [*renderizaci√≥n basada en claves* (key-based
rendering)](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) para mostrar c√≥mo se compara el rendimiento de Million.js con el de React.

<br />

<Demo />

## ¬øAlguna pregunta?

Si tienes alguna pregunta o necesitas soporte, no dudes en hacerlas en [Discord](https://million.dev/chat) o abrir un *issue* en [GitHub](https://github.com/aidenybai/million).
